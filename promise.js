/*
 * [promise.coffee](http://github.com/CodeCatalyst/promise.coffee) v1.0.3
 * Copyright (c) 2012-2013 [CodeCatalyst, LLC](http://www.codecatalyst.com/).
 * Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */
// Generated by CoffeeScript 1.6.3
(function() {
  var CallbackQueue, Deferred, Promise, Resolver, callbackQueue, enqueue, isFunction, isObject, nextTick, target;

  nextTick = (typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null ? process.nextTick : typeof setImmediate !== "undefined" && setImmediate !== null ? setImmediate : function(task) {
    return setTimeout(task, 0);
  };

  CallbackQueue = (function() {
    function CallbackQueue() {
      var execute, queuedCallbacks;
      queuedCallbacks = [];
      execute = function() {
        var index;
        index = 0;
        while (index < queuedCallbacks.length) {
          queuedCallbacks[index++]();
        }
        queuedCallbacks.length = 0;
      };
      this.schedule = function(callback) {
        if (queuedCallbacks.push(callback) === 1) {
          nextTick(execute);
        }
      };
    }

    return CallbackQueue;

  })();

  callbackQueue = new CallbackQueue();

  enqueue = function(task) {
    return callbackQueue.schedule(task);
  };

  isFunction = function(value) {
    return typeof value === 'function';
  };

  isObject = function(value) {
    return value === Object(value);
  };

  Resolver = (function() {
    function Resolver(onResolved, onRejected) {
      var complete, completeRejected, completeResolved, completed, completionAction, completionValue, pendingResolvers, process, processed, promise, propagate, resolve;
      promise = new Promise(this);
      pendingResolvers = [];
      processed = false;
      completed = false;
      completionValue = null;
      completionAction = null;
      if (!isFunction(onRejected)) {
        onRejected = function(error) {
          throw error;
        };
      }
      propagate = function() {
        var pendingResolver, _i, _len;
        for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
          pendingResolver = pendingResolvers[_i];
          pendingResolver[completionAction](completionValue);
        }
        pendingResolvers.length = 0;
      };
      complete = function(action, value) {
        onResolved = onRejected = null;
        completionAction = action;
        completionValue = value;
        completed = true;
        if (pendingResolvers.length > 0) {
          enqueue(propagate);
        }
      };
      completeResolved = function(result) {
        if (!completed) {
          complete('resolve', result);
        }
      };
      completeRejected = function(reason) {
        if (!completed) {
          complete('reject', reason);
        }
      };
      resolve = function(value) {
        var error, resolver, thenFn;
        try {
          if (value === promise) {
            throw new TypeError('A Promise cannot be resolved with itself.');
          }
          if ((isObject(value) || isFunction(value)) && isFunction(thenFn = value.then)) {
            try {
              resolver = new Resolver(resolve, completeRejected);
              thenFn.call(value, resolver.resolve, resolver.reject);
            } catch (_error) {
              error = _error;
              resolver.reject(error);
            }
          } else {
            completeResolved(value);
          }
        } catch (_error) {
          error = _error;
          completeRejected(error);
        }
      };
      process = function(value, callback) {
        processed = true;
        if (callback != null) {
          enqueue(function() {
            var error;
            try {
              if (isFunction(callback)) {
                value = callback(value);
              }
              resolve(value);
            } catch (_error) {
              error = _error;
              completeRejected(error);
            }
          });
        } else {
          resolve(value);
        }
      };
      this.resolve = function(result) {
        if (!processed) {
          process(result, onResolved);
        }
      };
      this.reject = function(reason) {
        if (!processed) {
          process(reason, onRejected);
        }
      };
      this.then = function(onResolved, onRejected) {
        var pendingResolver;
        if (isFunction(onResolved) || isFunction(onRejected)) {
          pendingResolver = new Resolver(onResolved, onRejected);
          pendingResolvers.push(pendingResolver);
          if (completed) {
            enqueue(propagate);
          }
          return pendingResolver.promise;
        }
        return promise;
      };
      this.promise = promise;
    }

    return Resolver;

  })();

  Promise = (function() {
    function Promise(resolver) {
      this.then = function(onFulfilled, onRejected) {
        return resolver.then(onFulfilled, onRejected);
      };
    }

    return Promise;

  })();

  Deferred = (function() {
    function Deferred() {
      var resolver;
      resolver = new Resolver();
      this.promise = resolver.promise;
      this.resolve = function(result) {
        return resolver.resolve(result);
      };
      this.reject = function(error) {
        return resolver.reject(error);
      };
    }

    return Deferred;

  })();

  target = typeof exports !== "undefined" && exports !== null ? exports : window;

  target.Deferred = Deferred;

  target.defer = function() {
    return new Deferred();
  };

}).call(this);
