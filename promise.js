/*
 * [promise.coffee](http://github.com/CodeCatalyst/promise.coffee) v1.0.6
 * Copyright (c) 2012-2013 [CodeCatalyst, LLC](http://www.codecatalyst.com/).
 * Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */
// Generated by CoffeeScript 1.6.3
(function() {
  var CallbackQueue, Consequence, Deferred, Promise, Resolver, callbackQueue, enqueue, isFunction, isObject, nextTick, target;

  nextTick = (typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null ? process.nextTick : typeof setImmediate !== "undefined" && setImmediate !== null ? setImmediate : function(task) {
    return setTimeout(task, 0);
  };

  CallbackQueue = (function() {
    function CallbackQueue() {
      var execute, queuedCallbackCount, queuedCallbacks;
      queuedCallbacks = new Array(1e4);
      queuedCallbackCount = 0;
      execute = function() {
        var index;
        index = 0;
        while (index < queuedCallbackCount) {
          queuedCallbacks[index]();
          queuedCallbacks[index] = null;
          index++;
        }
        queuedCallbackCount = 0;
      };
      this.schedule = function(callback) {
        queuedCallbacks[queuedCallbackCount++] = callback;
        if (queuedCallbackCount === 1) {
          nextTick(execute);
        }
      };
    }

    return CallbackQueue;

  })();

  callbackQueue = new CallbackQueue();

  enqueue = function(task) {
    return callbackQueue.schedule(task);
  };

  isFunction = function(value) {
    return value && typeof value === 'function';
  };

  isObject = function(value) {
    return value && typeof value === 'object';
  };

  Consequence = (function() {
    function Consequence(onFulfilled, onRejected) {
      this.onFulfilled = onFulfilled;
      this.onRejected = onRejected;
      this.resolver = new Resolver();
      this.promise = this.resolver.promise;
    }

    Consequence.prototype.trigger = function(action, value) {
      switch (action) {
        case 'fulfill':
          this.propagate(value, this.onFulfilled, this.resolver, this.resolver.resolve);
          break;
        case 'reject':
          this.propagate(value, this.onRejected, this.resolver, this.resolver.reject);
      }
    };

    Consequence.prototype.propagate = function(value, callback, resolver, resolverMethod) {
      if (isFunction(callback)) {
        enqueue(function() {
          var error;
          try {
            resolver.resolve(callback(value));
          } catch (_error) {
            error = _error;
            resolver.reject(error);
          }
        });
      } else {
        resolverMethod.call(resolver, value);
      }
    };

    return Consequence;

  })();

  Resolver = (function() {
    function Resolver() {
      this.promise = new Promise(this);
      this.consequences = [];
      this.completed = false;
      this.completionAction = null;
      this.completionValue = null;
    }

    Resolver.prototype.then = function(onFulfilled, onRejected) {
      var consequence;
      consequence = new Consequence(onFulfilled, onRejected);
      if (this.completed) {
        consequence.trigger(this.completionAction, this.completionValue);
      } else {
        this.consequences.push(consequence);
      }
      return consequence.promise;
    };

    Resolver.prototype.resolve = function(value) {
      var error, isHandled, self, thenFn;
      if (this.completed) {
        return;
      }
      try {
        if (value === this.promise) {
          throw new TypeError('A Promise cannot be resolved with itself.');
        }
        if ((isObject(value) || isFunction(value)) && isFunction(thenFn = value.then)) {
          isHandled = false;
          try {
            self = this;
            thenFn.call(value, function(value) {
              if (!isHandled) {
                isHandled = true;
                self.resolve(value);
              }
            }, function(error) {
              if (!isHandled) {
                isHandled = true;
                self.reject(error);
              }
            });
          } catch (_error) {
            error = _error;
            if (!isHandled) {
              this.reject(error);
            }
          }
        } else {
          this.complete('fulfill', value);
        }
      } catch (_error) {
        error = _error;
        this.reject(error);
      }
    };

    Resolver.prototype.reject = function(reason) {
      if (this.completed) {
        return;
      }
      this.complete('reject', reason);
    };

    Resolver.prototype.complete = function(action, value) {
      var consequence, _i, _len, _ref;
      this.completionAction = action;
      this.completionValue = value;
      this.completed = true;
      _ref = this.consequences;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        consequence = _ref[_i];
        consequence.trigger(this.completionAction, this.completionValue);
      }
      this.consequences = null;
    };

    return Resolver;

  })();

  Promise = (function() {
    function Promise(resolver) {
      this.then = function(onFulfilled, onRejected) {
        return resolver.then(onFulfilled, onRejected);
      };
    }

    return Promise;

  })();

  Deferred = (function() {
    function Deferred() {
      var resolver;
      resolver = new Resolver();
      this.promise = resolver.promise;
      this.resolve = function(value) {
        return resolver.resolve(value);
      };
      this.reject = function(reason) {
        return resolver.reject(reason);
      };
    }

    Deferred.resolve = function(value) {
      var deferred;
      deferred = new Deferred();
      deferred.resolve(value);
      return deferred.promise;
    };

    Deferred.reject = function(reason) {
      var deferred;
      deferred = new Deferred();
      deferred.reject(reason);
      return deferred.promise;
    };

    return Deferred;

  })();

  target = typeof exports !== "undefined" && exports !== null ? exports : window;

  target.Deferred = Deferred;

  target.defer = function() {
    return new Deferred();
  };

}).call(this);
