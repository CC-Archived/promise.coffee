/*
 * [promise.coffee](http://github.com/CodeCatalyst/promise.coffee) v1.0
 * Copyright (c) 2012-2013 [CodeCatalyst, LLC](http://www.codecatalyst.com/).
 * Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */
// Generated by CoffeeScript 1.4.0

(function() {
  var Deferred, Promise, Resolver, isFunction, nextTick, target;

  nextTick = (typeof process !== "undefined" && process !== null ? process.nextTick : void 0) || (typeof setImmediate !== "undefined" && setImmediate !== null) || function(task) {
    return setTimeout(task, 0);
  };

  isFunction = function(value) {
    return typeof value === 'function';
  };

  Resolver = (function() {

    function Resolver(onResolved, onRejected) {
      var complete, completeRejected, completeResolved, completed, completionAction, completionValue, pendingResolvers, process, processed, propagate, schedule;
      this.promise = new Promise(this);
      pendingResolvers = [];
      processed = false;
      completed = false;
      completionValue = null;
      completionAction = null;
      if (!isFunction(onRejected)) {
        onRejected = function(error) {
          throw error;
        };
      }
      propagate = function() {
        var pendingResolver, _i, _len;
        for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
          pendingResolver = pendingResolvers[_i];
          pendingResolver[completionAction](completionValue);
        }
        pendingResolvers = [];
      };
      schedule = function(pendingResolver) {
        pendingResolvers.push(pendingResolver);
        if (completed) {
          propagate();
        }
      };
      complete = function(action, value) {
        onResolved = onRejected = null;
        completionAction = action;
        completionValue = value;
        completed = true;
        propagate();
      };
      completeResolved = function(result) {
        complete('resolve', result);
      };
      completeRejected = function(reason) {
        complete('reject', reason);
      };
      process = function(callback, value) {
        processed = true;
        try {
          if (isFunction(callback)) {
            value = callback(value);
          }
          if (value && isFunction(value.then)) {
            value.then(completeResolved, completeRejected);
          } else {
            completeResolved(value);
          }
        } catch (error) {
          completeRejected(error);
        }
      };
      this.resolve = function(result) {
        if (!processed) {
          process(onResolved, result);
        }
      };
      this.reject = function(error) {
        if (!processed) {
          process(onRejected, error);
        }
      };
      this.then = function(onResolved, onRejected) {
        var pendingResolver;
        if (isFunction(onResolved) || isFunction(onRejected)) {
          pendingResolver = new Resolver(onResolved, onRejected);
          nextTick(function() {
            return schedule(pendingResolver);
          });
          return pendingResolver.promise;
        }
        return this.promise;
      };
    }

    return Resolver;

  })();

  Promise = (function() {

    function Promise(resolver) {
      this.then = function(onFulfilled, onRejected) {
        return resolver.then(onFulfilled, onRejected);
      };
    }

    return Promise;

  })();

  Deferred = (function() {

    function Deferred() {
      var resolver;
      resolver = new Resolver();
      this.promise = resolver.promise;
      this.resolve = function(result) {
        return resolver.resolve(result);
      };
      this.reject = function(error) {
        return resolver.reject(error);
      };
    }

    return Deferred;

  })();

  target = typeof exports !== "undefined" && exports !== null ? exports : window;

  target.Deferred = Deferred;

  target.defer = function() {
    return new Deferred();
  };

}).call(this);
